#!/usr/bin/env python3
"""
This is a collection of helper python function to use for analyzing and working with
multiple sequence alingment 
"""

import argparse

def GetParent(parent_dict, child):
    """
    Recursively finds the parent of a given child in a parent-child relationship dictionary.
    This function is useful for tracking identical sequences by traversing the parent-child
    hierarchy until the root parent is found.
    Parameters
    ----------
    parent_dict : dict
        A dictionary where keys are children and values are their respective parents.
    child : hashable
        The child element whose parent needs to be found.
    Returns
    -------
    hashable
        The root parent of the given child if found, or None if the child does not exist
        in the dictionary.
    Notes
    -----
    If the child is not found in the dictionary, a message is printed, and None is returned.
    The function does not explicitly return the result of the recursive call, which may
    lead to unexpected behavior.
    """
    parent = parent_dict.get(child, None)
    if parent:
        if parent == child:
            return child
        else:
            GetParent(parent_dict, child)
    else:
        print("Oops.. the entry does not exist!")
        return parent

def trim_alignment(msa, ref_id, id2record=None):
    """
    Trims a multiple sequence alignment (MSA) to remove gaps with respect to a reference sequence.
    - The function uses Biopython's `Seq` module to handle sequences
    - The trimming is performed by identifying positions in the reference sequence that are not gaps ('-')
    and removing the corresponding columns from the MSA
    - The input `msa` is modified in place
    Parameters
    ----------
    msa : list of Bio.SeqRecord.SeqRecord
        A list of sequence records representing the multiple sequence alignment (MSA).
    ref_id : str
        The sequence ID of the reference sequence in the MSA.
    id2record : dict, optional
        A dictionary mapping sequence IDs to their corresponding SeqRecord objects. 
        If not provided, it will be generated from the `msa`.
    Returns
    -------
    msa : list of Bio.SeqRecord.SeqRecord
        The trimmed MSA where gaps in the reference sequence have been removed.
        If the reference sequence is not found, the function returns `None`. 
    """
    import numpy as np
    from Bio import Seq

    if not id2record: 
        id2record = {rec.id: rec for rec in msa}
    ref_id_refseq = id2record.get(ref_id, None)
    if not ref_id_refseq: 
        print("Reference is not in the alignment!")
        return

    # Trim the MSA
    trim_ref = np.array(ref_id_refseq) != '-'
    trim_aln = np.array(msa)[:, trim_ref]
    for rec, rec_row in zip(msa, trim_aln):
        rec.seq = Seq.Seq(''.join(rec_row))

    return msa

def refine_alignment(input_file, id2record=None, output_file=None, dup_flag=False, ref_id='NC_045512_China_2019-12'):
    """
    Refines a multiple sequence alignment (MSA) by removing redundant, identical sequences 
    and optionally saving a list of duplicate sequences. The refined MSA is written to a new file.
    Parameters
    ----------
    input_file : str
        Path to the input MSA file in FASTA format.
    id2record : dict, optional
        A dictionary mapping sequence labels to IDs. If not provided, sequence IDs will be used as-is.
    output_file : str, optional
        Path to the output file for the refined MSA. If not provided, the output file name is 
        generated by replacing '-aln' with '-aln_refined_trimmed' in the input file name.
    dup_flag : bool, optional
        If True, saves a list of duplicate sequences to a TSV file. Default is False.
    ref_id : str, optional
        Reference sequence ID used for trimming the alignment. Default is 'NC_045512_China_2019-12'.
    Returns
    -------
    None
        The function writes the refined MSA to the specified output file and optionally saves 
        a TSV file with duplicate sequence information.
    Notes
    -----
    - The function uses Biopython for handling MSA files.
    - Duplicate sequences are identified by comparing sequences after replacing gaps ('-') with 'N'.
    - A dictionary of parent-child relationships is maintained to track duplicates.
    - If `dup_flag` is True, a TSV file is generated with information about duplicate sequences.
    Raises
    ------
    FileNotFoundError
        If the input MSA file does not exist.
    Examples
    --------
    Refine an alignment and save the output to a new file:
    >>> refine_alignment("input-aln.fasta", outFile="output-aln_refined.fasta")
    Refine an alignment and save duplicate sequence information:
    >>> refine_alignment("input-aln.fasta", dupFlag=True)
    """
    import os
    import pandas as pd
    from Bio import AlignIO
    from Bio.Align import MultipleSeqAlignment

    if not os.path.exists(input_file): 
        print("Can't find the alignment file!!")
        return
    if not output_file: 
        output_file = input_file.replace('-aln', '-aln_refined_trimmed')
    msa_raw = AlignIO.read(input_file, 'fasta')
    msa_raw = trim_alignment(msa_raw, ref_id)
    parent_IDs = {rec.id: rec.id for rec in msa_raw}
    remove_IDs = []
    # Find sequence IDs to remove from the MSA
    for i, rec_i in enumerate(msa_raw):
        if i % 500 == 0: 
            print("Processing record {}".format(i+1))
        for j, rec_j in enumerate(msa_raw):
            if (rec_j.id not in remove_IDs):
                seq_i = str(rec_i.seq).replace('-','N')
                seq_j = str(rec_j.seq).replace('-','N')
                if (seq_i == seq_j) and (i < j):
                    remove_IDs.append(rec_j.id)
                    parent_IDs[rec_j.id] = GetParent(parent_IDs, rec_i.id)

    child_IDs = {k: [] for k in parent_IDs.keys()}
    for i,k in enumerate(child_IDs.keys()):
        if i % 500 == 0: 
            print("Processing record {}".format(i+1))
        child_IDs[parent_IDs[k]].append(k)
    msa_new = MultipleSeqAlignment([rec for rec in msa_raw if rec.id not in remove_IDs])
    print("Writing the trimmed and refined MSA to the file {}".format(output_file))
    AlignIO.write(msa_new, output_file, 'fasta')

    # Save duplicate sequence IDs to a file
    if dup_flag:
        if not id2record: 
            id2record = {rec.id: rec.id for rec in msa_raw}
        dup_dict = {v: {'recName': k, 'duplicates': ''} for k,v in id2record.items()}
        for k,v in child_IDs.items():
            if len(v) > 1:
                parent = id2record.get(k, k)
                v.remove(k)
                if parent not in dup_dict.keys():
                    parent = [k for k,v in dup_dict.items() if v == '_'.join(parent.split('_')[:3])][0]
                dup_dict[parent]['duplicates'] = '|'.join(v)

        df = pd.DataFrame([v for v in dup_dict.values()], index=dup_dict.keys())
        df.to_csv(input_file.replace('.fasta', '.tsv').replace('-aln','-aln_dups'), 
                  index=True, header=True, columns=df.columns, sep='\t')
    return

def main():
    parser = argparse.ArgumentParser(description="Trim and refine a MSA alignment to remove gaps, "
                                     "duplicated sequences and incorrect entries")
    parser.add_argument("input_file", help="Input MSA alignment file in fasta format")
    parser.add_argument("output_file", type=str, default=None, help="Path to the output file " 
                        "for the refined MSA. If not provided, the output file name is generated by replacing "
                        "'-aln' with '-aln_refined_trimmed' in the input file name.")

    args = parser.parse_args()
    input_file = args.input_file
    output_file = args.output_file

    refine_alignment(input_file, output_file=output_file)

if __name__ == "__main__":
    main()